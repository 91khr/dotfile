#if 0
out=$(mktemp)
dotpath=$(readlink -f $(dirname $0))
homepath=$HOME
if g++ $0 -std=c++20 -o $out \
    -DDOTPATH="\"$dotpath\"" -DHOMEPATH="\"$homepath\""; then
    exec $out $@
else
    exit $?
fi
#endif
// {{{ Premable

#include <cstdio>
#include <fstream>
#include <cstdlib>
#include <string>
#include <filesystem>
#include <list>
#include <tuple>
#include <algorithm>
#include <unordered_map>
#include <unordered_set>
#include <functional>
using std::string;
namespace fs = std::filesystem;
// }}} End premable

// {{{ Environment & options
struct {
    string dotpath, homepath;
    const bool iswin =
#ifdef _WIN32
        true
#else
        false
#endif
        ;  // Resume the Vim indent ><
    const char *helpmsg = R"(Usage: %s <options> <configs>
A dotfile installation helper. If no option is specified, default to -i,
if no config is specified either, default is -l.
A special config 'available' stands for all config available on the system;
and 'everything' stands for all config

  -h, --help    print the message and quit
  -i, --install install given configurations
  -l, --list    list information of given configurations, grouped by their state.
                if not given, list all configurations
  -r, --reached list installed configurations
  -u, --pending list configurations not yet installed
)";
} env;
// }}} End environment & options

// {{{2 Config helpers
struct ConfigInfo
{
    string name;
    enum {
        UNIX, Win, All,
    } os;
    string description;
    inline static const char *OSName[] = { "UNIX", "Win", "All" };
    std::function<void()> install;
    std::function<bool()> is_installed;
};

std::unordered_map<string, ConfigInfo> conf_list;
std::list<std::function<ConfigInfo()>> conf_list_fns;
#define add_conf_impl(ln) struct AddConf##ln { \
    AddConf##ln(std::function<ConfigInfo()> info) { conf_list_fns.push_back(info); } \
} addconf_var##ln
#define add_conf_2(ln) add_conf_impl(ln)
#define add_conf add_conf_2(__LINE__)

class InvokerConfig
{
private:
    fs::path file;
    const string begline, endline;
    string commands;
    std::list<string> readfile()
    {
        std::list<string> res;
        std::ifstream in(file);
        if (!in)
            return res;
        while (!in.eof())
        {
            res.push_back("");
            std::getline(in, res.back());
        }
        return res;
    }
public:
    InvokerConfig(fs::path f, string comment_prefix, string name, string cmd)
        : file(env.homepath / f),
          begline(comment_prefix + " {{{ Generated by dotfile installer: " + name),
          endline(comment_prefix + " }}} End dotfile installer generated: " + name),
          commands(cmd) { if (commands.back() != '\n') commands.push_back('\n'); }
    void install()
    {
        auto ctnt = readfile();
        auto insertion = begline + "\n" + commands + endline;
        auto beg = std::find(ctnt.begin(), ctnt.end(), begline);
        auto end = std::find(ctnt.begin(), ctnt.end(), endline);
        if (end == ctnt.end())
            ctnt.push_back(insertion);
        else
        {
            ctnt.insert(beg, insertion);
            ctnt.erase(beg, ++end);
        }
        if (!fs::exists(file.parent_path()))
            fs::create_directories(file.parent_path());
        std::ofstream out(file);
        for (auto line : ctnt)
            out << line << "\n";
        out.close();
    }
    bool is_installed()
    {
        auto ctnt = readfile();
        return std::find(ctnt.begin(), ctnt.end(), begline) != ctnt.end();
    }
};

string format(string pat, string car, auto ...cdr)
{
    if (int pos = pat.find('$'); pos != pat.npos)
        pat.replace(pos, 1, car);
    if constexpr (sizeof...(cdr))
        return format(pat, cdr...);
    else
        return pat;
}
// }}}2 End config helpers

// {{{ Main
int main(int argc, char **argv)
{
    // {{{ Process default parameters
    env.dotpath =
#ifndef DOTPATH
        fs::absolute(fs::path(argv[0]).parent_path());
#else
        DOTPATH;
#endif  // DOTPATH
        ;  // Resume the Vim indent ><
    env.homepath =
#ifndef HOMEPATH
        std::getenv(env.iswin ? "USERPROFILE" : "HOME")
#else
        HOMEPATH
#endif  // HOMEPATH
        ;  // Resume the Vim indent ><
    // }}} End process default parameters
    for (auto fn : conf_list_fns)
    {
        auto info = fn();
        conf_list[info.name] = info;
    }
    // {{{ Process command-line arguments
    enum {
        Unset, Install, List, Reached, Pending,
    } operation(Unset);
    std::unordered_map<string, std::function<void()>> longopt_fns;
    std::unordered_map<char, std::function<void()>> shortopt_fns;
    std::unordered_set<string> selected_config;
    auto check_operation = [&] {
        if (operation != Unset)
        {
            printf("Duplicate actions!\n");
            exit(1);
        }
    };
    auto copyall = [&] (bool everything) {
        selected_config.clear();
        for (auto &it : conf_list)
            if (everything || it.second.os == ConfigInfo::All ||
                    ((it.second.os == ConfigInfo::Win) == env.iswin))
                selected_config.insert(it.first);
    };
    for (auto it : std::initializer_list<std::tuple<const char*, char, std::function<void()>>> {
        { "help", 'h', [&] { printf(env.helpmsg, argv[0]); exit(0); }, },
        { "install", 'i', [&] { check_operation(); operation = Install; }, },
        { "list", 'l', [&] { check_operation(); operation = List; }, },
        { "reached", 'r', [&] { check_operation(); operation = Reached; copyall(false); }, },
        { "pending", 'u', [&] { check_operation(); operation = Pending; copyall(false); }, },
    })
    {
        longopt_fns[std::get<0>(it)] = std::get<2>(it);
        shortopt_fns[std::get<1>(it)] = std::get<2>(it);
    }
    for (char **arg = argv + 1; *arg; ++arg)
    {
        string curarg = *arg;
        if (curarg.starts_with("--"))  // Long option
        {
            bool ok = false;
            for (auto it : longopt_fns)
                if (it.first.starts_with(curarg.substr(2)))
                {
                    it.second();
                    ok = true;
                    break;
                }
            if (!ok)
                fprintf(stderr, "Error: unrecognized option %s\n", *argv);
        }
        else if (curarg.starts_with("-"))  // Short arg
        {
            for (auto ch : curarg.substr(1))
                if (auto it = shortopt_fns.find(ch); it != shortopt_fns.end())
                    it->second();
                else
                    fprintf(stderr, "Error: unrecognized option %c\n", ch);
        }
        else  // Ordinary config
        {
            if (curarg == "everything" || curarg == "available")
                copyall(curarg == "everything");
            else if (!selected_config.contains(curarg))
            {
                if (conf_list.find(curarg) != conf_list.end())
                    selected_config.insert(curarg);
                else
                    printf("Unrecognized config: %s\n", curarg.c_str());
            }
        }
    }
    // }}} End processing command-line arguments
    // Perform operation
    if (operation == Unset)
        operation = selected_config.empty() ? List : Install;
    if (operation == List && selected_config.empty())
        copyall(true);
    std::list<ConfigInfo> installed, pending;
    for (auto name : selected_config)
    {
        auto it = conf_list[name];
        (it.is_installed() ? installed : pending).push_back(it);
    }
    switch (operation)
    {
    case Unset:  // Impossible ><
    case List:
        puts("Installed:");
        for (auto it : installed)
            printf("  %s(%s): %s\n", it.name.c_str(), it.OSName[it.os], it.description.c_str());
        puts("Not yet installed:");
        for (auto it : pending)
            printf("  %s(%s): %s\n", it.name.c_str(), it.OSName[it.os], it.description.c_str());
        break;
    case Reached:
    case Pending:
        for (auto it : operation == Reached ? installed : pending)
            printf("%s ", it.name.c_str());
        puts("");
        break;
    case Install:
        for (auto it : pending)
        {
            printf("Installing %s\n", it.name.c_str());
            it.install();
        }
        break;
    }
}
// }}} End main

add_conf([] () -> ConfigInfo {
    static InvokerConfig profile{ ".profile", "#", "profile", format("source $/profile/profile", env.dotpath) };
    static InvokerConfig xprofile{ ".xprofile", "#", "profile", format("source $/profile/xprofile", env.dotpath) };
    static InvokerConfig xres{ ".Xresources", "!", "profile",
        format(R"(#include "$/profile/Xresources"
#include "$/profile/Solarizedxterm/Xdefaults")", env.dotpath, env.dotpath) };
    return {
        .name = "profile", .os = ConfigInfo::UNIX,
        .description = "Default user profiles",
        .install = [&] {
            profile.install();
            xprofile.install();
            xres.install();
        },
        .is_installed = [&] {
            return profile.is_installed() && xprofile.is_installed() && xres.is_installed();
        },
    };
});

add_conf([] () -> ConfigInfo {
    static InvokerConfig zsh{ ".zshrc", "#", "zshrc", format("source $/zsh/zshrc", env.dotpath) };
    return {
        .name = "zshrc", .os = ConfigInfo::All,
        .description = "Z shell config",
        .install = [&] { zsh.install(); },
        .is_installed = [&] { return zsh.is_installed(); },
    };
});

add_conf([] () -> ConfigInfo {
    static InvokerConfig vim{ ".vimrc", "\"", "vimrc", format("source $/vim/vimrc", env.dotpath) };
    return {
        .name = "vimrc", .os = ConfigInfo::All,
        .description = "Vim config",
        .install = [&] { vim.install(); },
        .is_installed = [&] { return vim.is_installed(); },
    };
});

add_conf([] () -> ConfigInfo {
    static InvokerConfig emacs{ ".emacs.d/init.el", ";;", "emacs conf",
        format("(load-file \"$/emacs/init.el\")", env.dotpath) };
    return {
        .name = "emacsrc", .os = ConfigInfo::All,
        .description = "Emacs config",
        .install = [&] { emacs.install(); },
        .is_installed = [&] { return emacs.is_installed(); },
    };
});

add_conf([] () -> ConfigInfo {
    static InvokerConfig mutt{ ".mutt/muttrc", "#", "mutt",
        format(R"(set my_muttrc_path = $/mutt
source $/mutt/muttrc)", env.dotpath, env.dotpath) };
    return {
        .name = "mutt", .os = ConfigInfo::UNIX,
        .description = "Mutt config",
        .install = [&] { mutt.install(); },
        .is_installed = [&] { return mutt.is_installed(); },
    };
});

add_conf([] () -> ConfigInfo {
    static InvokerConfig awesome{ ".config/awesome/rc.lua", "--", "awesome",
        format(R"(loadfile("$/awesome/rc.lua")("$"))", env.dotpath, env.dotpath) };
    return {
        .name = "awesome", .os = ConfigInfo::UNIX,
        .description = "AwesomeWM config",
        .install = [&] { awesome.install(); },
        .is_installed = [&] { return awesome.is_installed(); },
    };
});

// vim: fdm=marker
