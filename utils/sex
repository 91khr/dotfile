#!/usr/bin/env python3
import argparse, textwrap, sys, re, subprocess

def wrap_para(para: [str]) -> str:
    return "\n\n".join(['\n'.join(textwrap.wrap(textwrap.dedent(s), width=80)) for s in para])
def escape(s: str) -> str:
    return re.sub("'", """' .. "'" .. '""", s)

class CmdAction(argparse.Action):
    max_cmdid = 0
    cmdmap = {
            'c': lambda c: "exec '%" + escape(c) + "'",
            'e': lambda c: "exec '" + escape(c) + "'",
            's': lambda c: "source " + c,
        }
    def __call__(self, parser, namespace, values, opt_str=None):
        setattr(namespace, 'extcmd', getattr(namespace, 'extcmd', []) + [CmdAction.cmdmap[self.dest](values)])
        CmdAction.max_cmdid += 1

parser = argparse.ArgumentParser(description = wrap_para(
    [
        "Stream ex, like sed, but more powerful by basing on Vim.",
        "If no commands or script files given, this message will be printed.",
        """\
        The input commands by -c will be prepended a '%' as its range and sent to vim for execution,
        so that they will affect every line. Commands passed by -e won't go through such preprocess.
        The script files are executed with 'source' command.
        """,
        """\
        The extra commands and the script files would be executed in the order they appear in the argument list,
        and the positional command, if present, would always be executed the first.
        """,
        ]),
    formatter_class=argparse.RawDescriptionHelpFormatter,
    )
parser.add_argument("-n", "--quiet", const=True, default=False, action="store_const",
        help="Not printing the result buffer after all processings")
parser.add_argument("-c", metavar="command", action=CmdAction, help="Extra input command")
parser.add_argument("-e", metavar="full-command", action=CmdAction,
        help="Extra input command that will not be preprocessed")
parser.add_argument("-s", metavar="script-file", action=CmdAction,
        help="Script files to be executed for the whole input")
parser.add_argument("command", nargs='?',
        help="files to process, if found none, read from stdin")
parser.add_argument("files", metavar="input-files", nargs='*',
        help="files to process, if found none, read from stdin")

args = parser.parse_args()
if getattr(args, 'extcmd', None) == None:
    setattr(args, 'extcmd', None)
if args.command == None and args.extcmd == None:
    parser.print_help()
    sys.exit()
sys.exit(subprocess.run([
    'vim', '-', '--not-a-term', '--clean', '-esc',
    "|".join((["exec '%" + escape(args.command) + "'"] if args.command else []) + (args.extcmd or [])),
    '-c', '{}q!'.format("" if args.quiet else "%print|"),
    ],
    input = None if args.files == [] else b"".join((b"".join(open(f, "rb").readlines()) for f in args.files))
    ).returncode)
